#!/usr/bin/env python3
import os
import sys
import fcntl
import termios
import tty
import select
import signal
import struct
import errno
import re
import locale

initial_timeout = 10
continued_timeout = 1
prompt = b'\xe2\x80\xba'

_ansi_re = re.compile(
  br"""
  \x1b(?:                                 # ESC
      [A-Z]                               # C1 controls
    | \[ [0-?]* [ -/]* [@-~]              # CSI ... final byte (per ECMA-48)
    | \] (?: [^\x07\x1b]* (?:\x07|\x1b\\) )   # OSC ... BEL or ESC\
    | P  (?: [^\x1b]* (?:\x1b\\|\x07) )       # DCS (P) ... ESC\ or BEL
    | [\x50\x58\x5e\x5f] (?: [^\x1b]* \x1b\\ ) # SOS (X), PM (^), APC (_) ... ESC\
    | [@-Z\\\-_]                           # 2-char sequences like ESC @ ESC A etc.
  )
  """,
  re.VERBOSE
)

def to_plain_text(s, strip_start = False):
  """
  Remove ANSI escape sequences and special characters.
  """
  match_end = 0
  delta = 0
  def repl(m):
    nonlocal match_end, delta
    match_end = m.end()
    delta += (m.end() - m.start())
    return b''

  s = re.sub(rb'\x1b\[0m', b'\r', s)
  s = re.sub(rb'\x1b\[K', b'\r', s)
  s = re.sub(rb'\x1b\[\d+;\d+H', b' ', s)
  s = _ansi_re.sub(repl, s)
  #s = s.replace(b'\xe2\x80\xba', b'')
  unmatched = s[match_end - delta:]
  s = s[:match_end - delta]

  # we process unmatched until the first unmatched escape
  if (unmatched_until := unmatched.find(b'\x1b')) < 0:
    s += unmatched
    unmatched = b''
    unmatched_until = 0
  else:
    s += unmatched[:unmatched_until]
    unmatched = unmatched[unmatched_until:]
  enc = locale.getpreferredencoding(False)
  s = s.decode(enc, errors="ignore")
  s = "".join(ch for ch in s if not ((0x2800 <= ord(ch) <= 0x28FF) or (0x2500 <= ord(ch) <= 0x259F)))
  s = re.sub(r'\s*[\r\n]+\s*', '\n', s)
  s = re.sub(r'[ \t]{2,}', ' ', s)
  if strip_start: s = s.lstrip();
  s = s.encode(enc)
  return s + unmatched, len(s)

def _get_winsize(fd):
  s = struct.pack("HHHH", 0, 0, 0, 0)
  try:
    x = fcntl.ioctl(fd, termios.TIOCGWINSZ, s)
    rows, cols, _, _ = struct.unpack("HHHH", x)
    return rows, cols
  except Exception:
    return None

def _set_winsize(fd, rows, cols):
  s = struct.pack("HHHH", rows, cols, 0, 0)
  try:
    fcntl.ioctl(fd, termios.TIOCSWINSZ, s)
  except Exception:
    pass

import subprocess, pty

def spawn_with_pty(cmd):
  pid, master_fd = pty.fork()
  if pid == 0:
    os.execvp(cmd[0], cmd)
  else:
    return master_fd

def spawn_with_pty_alt(cmd):
    master_fd, slave_fd = pty.openpty()
    subprocess.Popen(cmd, stdin=slave_fd, stdout=slave_fd, stderr=slave_fd, start_new_session=True, close_fds=True, bufsize=0)
    os.close(slave_fd)
    return master_fd

def run_command(cmd, inputs, headless = False):
  inputs = [val for input in inputs for val in (input, '\r')]
  stdin_fd = sys.stdin.fileno()
  stdout_fd = sys.stdout.fileno()

  p_fd = spawn_with_pty(cmd)

  stdin_flags = fcntl.fcntl(stdin_fd, fcntl.F_GETFL)
  fcntl.fcntl(stdin_fd, fcntl.F_SETFL, stdin_flags | os.O_NONBLOCK)

  flags = fcntl.fcntl(p_fd, fcntl.F_GETFL)
  fcntl.fcntl(p_fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)

  tty_attrs_save = None
  if os.isatty(stdin_fd) and os.isatty(stdout_fd):
    tty_attrs_save = termios.tcgetattr(stdin_fd)
    tty.setraw(stdin_fd)

  winsize = _get_winsize(stdin_fd) if os.isatty(stdin_fd) else ( 24, 80 )
  if winsize:
    _set_winsize(p_fd, winsize[0], winsize[1])

  winch_save = None
  def _sigwinch_handler(signum, frame):
    ws = _get_winsize(stdin_fd) if os.isatty(stdin_fd) else ( 24, 80 )
    _set_winsize(p_fd, ws[0], ws[1])
    p.send_signal(signal.SIGWINCH)

  winch_save = signal.signal(signal.SIGWINCH, _sigwinch_handler)

  data_out = b''
  data_in = b''
  have_prompt = False
  strip_start = True
  timeout = initial_timeout

  while True:
    r_fds = []
    w_fds = []
    if p_fd is not None: r_fds.append(p_fd)
    if p_fd is not None and len(data_in) > 0: w_fds.append(p_fd)
    if stdin_fd is not None: r_fds.append(stdin_fd)
    if stdout_fd is not None and len(data_out) > 0: w_fds.append(stdout_fd)
    r, w, x = select.select(r_fds, w_fds, [], timeout)

    if not (r or w or x):
      timeout = continued_timeout
      have_prompt = True

    # data from process
    if p_fd in r:
      data = os.read(p_fd, 4096)
      if data:
        if b'\x1b[6n' in data:
            data_in = b'\x1b[25;1R'
            data = data.replace(b'\x1b[6n', b'')
        if prompt in data:
          have_prompt = True
        data_out += data
      else:
        break

    # write if data
    if stdout_fd in w and len(data_out) > 0:
      try:
        write_size = len(data_out)
        if not os.isatty(stdout_fd):
          ( data_out, write_size) = to_plain_text(data_out, strip_start)
          if len(data_out): strip_start = data_out.endswith(b'\n')
        n = os.write(stdout_fd, data_out[:write_size])
        if n:
          data_out = data_out[n:]
      except:
        break

    # inputs from arguments
    if len(inputs) and have_prompt and len(data_out) == 0 and len(data_in) == 0:
       have_prompt = False
       data_in = bytes(inputs[0] + '\r', 'utf8')
       inputs = inputs[1:]
    # input from stdin
    elif stdin_fd in r:
      inp = os.read(stdin_fd, 1024)
      if inp:
        data_in += inp

    if p_fd in w and len(data_in) > 0:
      try:
        n = os.write(p_fd, data_in)
        if n:
          data_in = data_in[n:]
      except:
        break

  fcntl.fcntl(stdin_fd, fcntl.F_SETFL, stdin_flags)

  if len(data_out):
    os.write(stdout_fd, data_out)

  if os.isatty(stdin_fd) and tty_attrs_save is not None:
    termios.tcsetattr(stdin_fd, termios.TCSADRAIN, tty_attrs_save)
  if winch_save is not None:
     signal.signal(signal.SIGWINCH, winch_save)

if __name__ == "__main__":
  if len(sys.argv) < 2:
    print(f"usage: {sys.argv[0]} COMMAND [ARG ...] -- [INPUT] ...")
    sys.exit(0)

  if '--' in sys.argv:
    i = sys.argv.index('--')
    command = sys.argv[1:i]
    inputs = sys.argv[i+1:]   # args after '--'
  else:
    command = sys.argv[1:]
    inputs = []
  run_command(command, inputs)
